

Это интраспекция, когда к нам приходит элемент и мы можем с помощью функции dir() понять кто он такой,
с помощью help() можно узнать, что с ним можно делать, а с помощью id() и is() можно понять тот ли это объект который я жду или какой-то другой.

https://docs.python.org/3/library/functions.htm

# -*- coding: utf-8 -*-

# Есть множество функций, которые встроены в интерпретатор

# известные нам
# input() - ввод из консоли
# print() - вывод на консоль
# enumerate() - выдать пары (номер элемента, значение) для списков
# range() - выдать последовательность целых чисел

# другие, наиболее употребляемые

# --- Приведение типов ---
Группа функций которая позволяет из одного типа данных , преобразовывать в другой

bool('0') True - строка с нолем это не ноль, часто в запросе от сервера прилетает строка.
int()
float()
bool()
str()
list()
tuple()
dict()
set() #можество

int('123')
int(123.45)
float('123')
float('123.45')
float(123)

bool(123)
bool(0)
bool(123.45)
bool(0.0)
bool('123')
bool('0')
bool('')
bool(None)

str(123)
str(123.45)
str(True)

my_tuple = (1, 2, 3, 3, 2, 1) # результат будет {1,2,3} - множетсва это уникальные объекты
list(my_tuple)

set(my_tuple)
my_dict = {1:2, 3:4}
list(my_dict) # Результат 1,3 - список только ключей, преобразование только по ключам
dict([('a', 2), ('b', 3), ]) # а такой словарь пар будет преобразован a 2 b 3



# --- Числа ---

# abs() - абсолютное значение числа
abs(1)
abs(-1)

# round() - округление до нужного знака
round(3.1425926, 2)
round(3.1425926, 3)
round(3.1425926, 0)

# --- Cписки ---

profit = [100, 20, 5, 1200, 42, ]

# len() - размер списка
len(profit)

# max() - максимальный элемент
max(profit)

# min() - минимальный элемент
min(profit)

# sorted() - отсортированный список
sorted(profit)

# sum() - сумма элементов списка
sum(profit)

# zip() - попарная компоновка элементов двух списков
profit = [100, 20, 5, 1200, 42, ]
days = ['пн', 'вт', 'ср', 'чт', 'пт', ]
res = zip(profit, days, )# res = list(zip(profit, days, ))
print(list(res)) #  print(dict(res)) два списка в один словарь


# --- Логические ---

# all() - True если ВСЕ элементы списка/множества True
all([True, True, True, True, ])
all([1, 0, 1, ])
all([1, '0', 1, ])

# any() - True если ХОТЯ БЫ ОДИН элемент списка True
any([True, False, True, True, ])
any([1, 0, None, ])

# --- Интроспекция ---

# dir() - список всех аттрибутов обьекта faq
dir(profit)
dir([])

# help() - встроенная помощь по функции/обьекту
help(profit)
help(print)

# id() - внутренний идентификатор обьекта, в Python все объекты, каталогизированный номер
#даже у чисел свой id, у None тоже свой id
a = [1, 2, 3]
print(id(a))
b = a
print(id(b))
c = [1, 2, 3]
print(id(c))
print(a == b, a is b, id(a) == id(b))
print(a == c, a is c, id(a) == id(c))
print(id(None))
print(id(False))
print(id(True))

id(a) == id(b) # False
a is b # сравнение id элементов - да\нет
a is None # a == None выполняется дольше


# --- Общего назначения ---

# hash() - значение хэша для обьекта. Что такое хэш-функции см https://goo.gl/gZLM4o
# Когда у нас очень длинная последовательность байт и мы с помощью определенных преобразований можем их свести к ограниченной последовательности байт
# Если на нас например два больших файла, который скачали и который лежит на сервере, что бы нам не подменили файл нужно на там свервере проверить хэш этого файла, передать нам по сети быстро,
# файл то может быть большой, файл может быть 100мб, а хэш от него 100-150 символов - зависит от функции которой вызываем.

# Хэш hash() можно брать только от неизменяемых объектов, потому что происходит внутренее хранение словаря
hash('Кржижановский')
hash(profit)

# isinstance() - является ли обьект обьектом данного класса
isinstance(profit, list)

# type() - тип(КЛАСС) обьекта
type(profit)

# open() - открыть файл на файловой системе
ff = open('lesson_004/lecture_snippets/05_builtin.py', 'r') # 'r' режим работы с файлом 'r' - чтение?, encoding='UTF8'
for line in ff.readlines():
    print(line, end='') # end= говорит функции, что делать после печати строки, закрывать строку или возврат каретки например.
ff.close()

https://docs.python.org/3/library/functions.htm


# будет целый урок по работе с файлами, пока просто ознакомились
